## 메모이제이션(memoization) 은?

연산의 결괏값을 메모리에 저장해 두고 이전 값과 결과가 동일 할때 재사용하는 기법입니다. (다시한번 연산하지 않고)

리엑트에서 상태가 변경되는 컴포넌트와 그 이하의 모든 자식 컴포넌트가 랜더링의 대상이 되고 자식 컴포넌트의 상태가 변경되지 않아도(갱신될 필요가 없어도) 불필요한 랜더링이 일어납니다.

리엑트에서 메모이제이션은 **React.memo**, **useCallback**(), **useMemo**() 등이 있습니다.

> **React.memo(컴포넌트), 
useCallback(() => { 함수 그 자체... }, []), 
useMemo(() => 함수의 리턴 값, [])**
> 

### React.Memo()

→ 컴포넌트 자체를 메모이제이션 합니다.

→ 자체적으로 props값을 비교해서 달라진 부분이 없다면 리엑트 DOM에서 비교작업이 들어가지 않습니다.

→ props값이 변하지 않았다면 컴포넌트 자체가 리렌더링 되지 않습니다.

→ 얕은 복사 레벨에서만 데이터를 비교하므로, 복잡한 구조의 데이터는 비교할 수없습니다.

### useCallback()

→ 함수 자체를 메모이제이션 합니다.

→ 자바스크립트에서 함수는 객체로 취급되기 때문에 리렌더링이 일어날때마다 새로운 함수가 생성됩니다.

→ 자식 컴포넌트의 불필요한 리렌더링을 막기 위해선 useCallback()으로 감싸줘야합니다.

→ 의존성 배열에 값이 변경되지 않는다면 이전에 생성한 함수의 참조 값을 반환해줍니다.

### useMemo()

→ 함수의 리턴 값을 메모이제이션 합니다.

→ 의존성 배열에 값이 변경되지 않는다면 메모이제이션 된 값을 사용합니다.

→ useMemo 에 전달된 함수는 렌더링 중에 실행되기 때문에 렌더링과 관련된 작업을 전달하는것이 적절합니다.

위 함수들의 공통점은 

- 리렌더링이 자주일어나지 않는다면 굳이 사용할 필요가 없습니다. (메모리에 불필요하게 남아있을 필요는 없으니까)
- props나 state가 변경되는 경우가 많을 경우 굳이 비교 작업이 계속할 필요가 없기 때문에 사용할 필요가 없습니다.
- 그래서 state나 props의 값이 어느 정도 적당히 변경되는 경우 사용하기 좋습니다.